# -*- coding: utf-8 -*-
"""Handwritten digit classification using KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cjGjVeWxmyLXkuvwuMDDkkkRDSbPv931
"""

!pip install collections
import numpy as np
import matplotlib.pyplot as plt
from collections import Counter
import tensorflow as tf

#loading the data that is already given to us in tensor flow
mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()

#normalize the pixel values that range from 0-255. normalized values(range 0-1) are more suitable for machine learning
x_train = tf.keras.utils.normalize(x_train, axis=1)

#flattening the 28x28 grid. 28 x 28 is the dimention of the digit image
x_flats = []
for x_obj in x_train:
  x_flats.append(x_obj.reshape([1,784]))

from collections import defaultdict

#filling up the dictionary containing all the labels(0 to 9) with several corresponding pixel values(flattened)
points = defaultdict(list)
for i, label in enumerate(y_train):
  points[label] += [x_flats[i]]

# normal euclidean distance formula. It is possible to use more advanced distances such as a weighted distance
def eucl_dist(p,q):
  return np.sqrt(np.sum((np.array(p)-np.array(q)) ** 2))

class KNearestNeighbors:
  def __init__(self,k=3):
    self.k = k
    self.point = None

  def fit(self, points):
    self.points = points

  def predict(self, new_point):
    distances=[]

    for category in self.points:
      for point in self.points[category]:
        distance = eucl_dist(point, new_point)
        distances.append([distance, category])
    categories = [category[1] for category in sorted(distances)[:self.k]]
    result = Counter(categories).most_common(1)[0][0]
    return result

#testing our algorithm with a random value from the test data. We preprocess the test data just as we did for training data
x_test = tf.keras.utils.normalize(x_test, axis=1)

clf = KNearestNeighbors()
clf.fit(points)
for i in range(10):
  new_point = x_test[i].reshape([1,784])
  print(y_test[i], '------>', clf.predict(new_point))









